<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raw Accel LUT Curve Maker</title>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body{
background:#000;
color:#fff;
font-family:Arial;
margin:0;
text-align:center;
}

header{
background:#111;
padding:20px;
font-size:26px;
}

header img{
height:60px;
display:block;
margin:auto;
margin-bottom:10px;
}

.container{
width:90%;
max-width:1000px;
margin:auto;
}

.card{
background:#111;
padding:20px;
margin-top:20px;
border-radius:12px;
}

input,select{
background:#000;
color:#fff;
border:1px solid #333;
padding:6px;
margin:5px;
width:120px;
}

button{
margin:8px;
padding:10px 16px;
background:#fff;
color:#000;
border:none;
border-radius:6px;
cursor:pointer;
}

textarea{
width:100%;
height:120px;
background:#000;
color:#fff;
border:1px solid #333;
margin-top:10px;
}

#error{
color:#ff5555;
margin-top:10px;
font-size:14px;
}
</style>
</head>

<body>

<header>
<img src="https://yt3.googleusercontent.com/G3NBG71dzJtbQ3ae2ERcVDRvXGEHaAlCO43-fnO-uilXeikc5mYWp2p2k4owzc4S5n0brzNC=s160-c-k-c0x00ffffff-no-rj">
Raw Accel LUT Curve Maker
</header>

<div class="container">

<div class="card">
DPI
<input id="dpi" value="800">

Poll Rate
<input id="poll" value="1000">

Curve Mode
<select id="curveMode" onchange="updateCurveMode()">
<option value="linear">Sharp</option>
<option value="smooth">Curvy</option>
</select>

<button onclick="applyScale()">Apply Scale</button>
</div>

<div class="card">
Paste existing LUT
<textarea id="importBox"></textarea>
<button onclick="importCurve()">Load Curve</button>
</div>

<div class="card">

<canvas id="chart"></canvas>

<button onclick="exportLUT()">Export LUT</button>
<button onclick="resetLine()">Reset Straight Line</button>

<div id="error"></div>

<textarea id="output"></textarea>

</div>
</div>

<script>

let dpi=800;
let poll=1000;
let zoom=1;

let points=[
{x:0.001,y:1},
{x:100,y:1}
];

const ctx=document.getElementById("chart");
const errorBox=document.getElementById("error");

function calculateMaxSpeed(){
return (dpi*poll/8000)*zoom;
}

const chart=new Chart(ctx,{
type:"line",
data:{
datasets:[{
data:points,
parsing:false,
borderColor:"white",
pointRadius:6,
tension:0
}]
},
options:{
animation:false,
responsive:true,
scales:{
x:{
type:"linear",
min:0.001,
max:calculateMaxSpeed(),
ticks:{color:"white"},
grid:{color:"#222"}
},
y:{
min:0,
max:2,
ticks:{color:"white"},
grid:{color:"#222"}
}
},
plugins:{legend:{display:false}}
}
});

/* CURVE MODE */
function updateCurveMode(){
chart.data.datasets[0].tension =
document.getElementById("curveMode").value==="smooth"
?0.4:0;
chart.update();
}

/* SCALE */
function applyScale(){
dpi=Number(document.getElementById("dpi").value)||800;
poll=Number(document.getElementById("poll").value)||1000;

chart.options.scales.x.max=calculateMaxSpeed();
chart.update();
}

/* VALIDATION */
function validateCurve(){

if(points.length<2)
return "Need at least 2 points";

if(points[0].x<=0)
return "First point X must be greater than 0";

for(let i=0;i<points.length;i++){

const p=points[i];

if(isNaN(p.x)||isNaN(p.y))
return "Invalid number detected";

if(i>0 && p.x<=points[i-1].x)
return "X values must increase left to right";
}

return null;
}

/* ZOOM */
ctx.addEventListener("wheel",e=>{
e.preventDefault();
zoom*=e.deltaY<0?1.1:0.9;
zoom=Math.max(.2,Math.min(zoom,10));
chart.options.scales.x.max=calculateMaxSpeed();
chart.update();
});

/* ADD */
ctx.onclick=e=>{
const r=ctx.getBoundingClientRect();

let x=chart.scales.x.getValueForPixel(e.clientX-r.left);
let y=chart.scales.y.getValueForPixel(e.clientY-r.top);

points.push({x:Math.max(0.001,x),y});
sortPoints();
updateChart();
};

/* DELETE */
ctx.oncontextmenu=e=>{
e.preventDefault();
const el=chart.getElementsAtEventForMode(
e,'nearest',{intersect:true},false
);
if(el.length){
points.splice(el[0].index,1);
updateChart();
}
};

/* DRAG */
let drag=null;

ctx.onmousedown=e=>{
const el=chart.getElementsAtEventForMode(
e,'nearest',{intersect:true},false
);
if(el.length) drag=el[0].index;
};

ctx.onmousemove=e=>{
if(drag===null) return;

const r=ctx.getBoundingClientRect();

points[drag].x=Math.max(
0.001,
chart.scales.x.getValueForPixel(e.clientX-r.left)
);

points[drag].y=
chart.scales.y.getValueForPixel(e.clientY-r.top);

sortPoints();
updateChart();
};

window.onmouseup=()=>drag=null;

function sortPoints(){
points.sort((a,b)=>a.x-b.x);
}

function updateChart(){
chart.data.datasets[0].data=points;
chart.update();
errorBox.textContent="";
}

/* IMPORT */
function importCurve(){
const text=document.getElementById("importBox").value;

const newPts=[];

text.split(";").forEach(p=>{
if(!p) return;
const [x,y]=p.split(",").map(Number);
if(x>0)newPts.push({x,y});
});

if(newPts.length){
points=newPts;
sortPoints();
updateChart();
}
}

/* EXPORT WITH BLOCK */
function exportLUT(){

const err=validateCurve();

if(err){
errorBox.textContent="Export blocked: "+err;
return;
}

const text=points
.map(p=>`${p.x.toFixed(3)},${p.y.toFixed(3)};`)
.join("");

document.getElementById("output").value=text;
errorBox.textContent="Export successful";
}

/* RESET */
function resetLine(){
points=[
{x:0.001,y:1},
{x:calculateMaxSpeed(),y:1}
];
updateChart();
}

updateChart();

</script>
</body>
</html>
